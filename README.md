# redis实战项目-类大众点评app
## DAY1
## 1.短信验证码发送功能实现
## controller接收post请求，由service处理：判断手机号是否合法->返回错误或生成验证码->调用hutool工具包中的randomUtil类生成六位随机数->保存验证码到redis，以手机号为key，ttl为2分钟，用于登录校验
## 2.用户短信登陆、拦截器部署
### 用户登录请求传递cookie，cookie中携带session id，session中保存了用户信息，通过session中保存的用户信息，可以在前置拦截器中校验登录信息从而显示页面，
### 并将用户信息保存到threadlocal中，从而在controller层中获取到该登录用户并返回完成校验，最后在后置拦截其中销毁threadlocal中的user值从而避免内存泄漏；
###  Session的实现原理：

服务端首先查找对应的cookie的值（sessionid）。
根据sessionid，从服务器端session存储中获取对应id的session数据，进行返回。
如果找不到sessionid，服务器端就创建session，生成sessionid对应的cookie，写入到响应头中。
## DAY2
## 1.用redis代替session实现短信登录功能从而解决session集群共享问题；所谓session集群共享问题：
多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。
session的替代方案应该满足：
数据共享
内存存储
key、value结构
## 因此可以采用redis代替tomcat session存储session数据

## --校验验证码通过后，uuid生成用户token，以token为key，以map存储的用户信息为value，存放到redis hash结构中，拦截器校验请求时，先获取请求头中token，再从redis中查找该token，找到后获取value中的用户信息，存放到threadlocal中以便后续使用，需要注意的是，这里应该刷新token有效期，因为要满足只要用户还在访问就不应该让token失效，以免用户访问过程中被拦截，影响用户体验，之后放行即可；
## 对拦截器进一步优化：拆分为token刷新拦截器和登录校验拦截器
## 前者实现上述拦截功能，后者通过获取threadlocal中的user信息判断是否拦截，在mvc配置类中启用拦截器即可；对登录校验拦截器可放行部分功能，从而避免非登录用户无功能可用。

## 2.添加redis缓存让频繁访问的数据能在缓存命中，从而减少数据库访问以降低数据库压力，提高响应速度--商店详情页面查询、首页商店类型查询->先查询redis->存在，返回->不存在，查询数据库，写回redis，返回。


## DAY3
## 1.redis缓存更新策略
-先更新数据库再删除缓存，保证事物一致性

## 2.redis缓存穿透问题被动解决方案-缓存空值法
## 使用布隆过滤器解决根据id查询商铺时存在的缓存穿透问题，使用的是redission自带RBloomFilter类，传入两个参数：预计插入数据数、误判率，布隆过偏滤器根据这两个参数，使用算法确定最终的二进制数组长度和hash函数个数，对插入的数据使用k个hash函数计算得到k个hash值，取模数组长度后得到索引下标，将数组相应下标值由0改为1即表示存储该数据，这样就可能存在hash冲突问题，如多个数据hash到了同一个下标，在查询数据时，同样得到该数据对应的索引下标，判断是否都为1，若是，则放行（由于hash冲突，可能会误判为存在），有一个为零则说明不存在，拒绝访问（一定不存在）。
## 3.缓存雪崩
## --缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。
## --解决方案：
给不同的Key的TTL添加随机值
利用Redis集群提高服务的可用性
给缓存业务添加降级限流策略
给业务添加多级缓存

## 4.缓存击穿（热点key问题）
### 某个 被高并发访问 并且 缓存重建业务较复杂 的key突然失效，无数请求访问瞬间冲击数据库

## 解决方案：
## --互斥锁：查询未命中，线程请求访问数据库并重建缓存，在此之前需要先请求锁，没请求到的线程自旋重试，占锁线程重建完成后释放锁，其余线程重试后发现缓存命中，直接返回，保证一致性，实现简单，无额外内存消耗，但线程自旋等待浪费了性能，并且有死锁风险（没释放锁）
## --逻辑过期：不给热点缓存设置ttl，而是逻辑上存储一个过期值字段，实际上永不过期，线程查询缓存时若命中则需要判断逻辑时间是否过期，如果过期则请求锁，请求成功会创建一个新线程
## 去重建缓存和重置过期时间，完成后释放锁，获取失败则返回旧的缓存值，不会等待，性能较好，但不保证一致性（客户得到的数据可能是过期数据），有额外内存消耗


## DAY4
## 1.互斥锁解决缓存击穿，使用JMeter进行多线程并发访问压测
## 2.逻辑过期解决缓存击穿
## 3.缓存相关set、get方法封装为工具类
## 4.基于redis自增实现全局唯一Id，由时间戳+redis自增+当前日期区分key位运算拼接成的64位long型id
符号位（1位，始终为0）+时间戳（31）+计数器（以天为key区分，redis自增，便于统计订单量，32位）
对比雪花算法：
![image](https://github.com/p0t4tt0/redis-/assets/147514081/cfc72c18-7765-45e0-aa8d-0b817e3716af)

## 5.优惠券添加、秒杀优惠券下单功能实现
## 6.解决秒杀多线程并发导致的超卖问题
### 两种方案：
### --悲观锁：给线程加锁，让所有线程串行执行，性能差，无线程安全问题
### --乐观锁：不加锁，更新前通过判断是否有线程已经做了修改从而决定是否修改，可以通过添加版本号字段或者比较库存前后值即CAS法决定是否修改，性能高但线程执行成功率低，可以通过判断库存是否大于零而不是等于查询时库存值来提高成功率。
## 7.用户一人一单功能，使用悲观锁synchronized处理用户下单操作，防止一个用户多次下单，要注意锁的是每个用户的id并且范围应该锁住整个事物,涉及的spring事物失效问题，需要获取代理对象实现
## DAY5
## 1.redis分布式锁
### 多台服务器集群处理高并发请求时，同一个用户的多个请求会被负载均衡到不同tomcat服务器，从而由不同jvm中的线程处理，导致不同请求获取到了不同的锁，每个请求都可访问数据库带来线程安全问题，因此采用分布式锁给不同服务器建立一个唯一的锁
### redis可以通过set nx ex实现；
## 2.解决分布式锁锁误删问题
### 线程获取锁后可能发生长时间阻塞导致锁过期释放，这时其他线程获取到锁后执行业务，此时阻塞线程唤醒并释放了锁，那么这次释放的锁就是其他线程的锁，从而导致安全问题，因此在释放锁前应对线程标识做判断。

## 3.解决释放锁操作的原子性问题
### 释放锁操作涉及两个步骤，第一步是判断线程标识，第二部是释放锁，如果第一步判断成立，还没执行第二步时，jvm虚拟机执行垃圾清理强行阻塞进程，导致锁超时释放，就会造成如上重复释放误删问题，因此必须确保两步操作的原子性，可以采用lua脚本实现，redis可通过EVAL字段
### 调用lua脚本，只需在lua脚本中完成这两布即可。

## 4.redisson 代替自定义分布式锁
### redisson 是一个基于redis的更完善的分布式锁组件，可以导入依赖并进行配置后直接使用。
### redisson 具有可重入锁功能，同一个线程中，方法a获取了锁后调用另一个方法b，方法b同样请求锁，而此时锁被a使用中，b无法获取，从而b无法完成，而a也阻塞在b方法上，无法释放锁，造成死锁问题，redisson可以让b获取到锁，其原理是用redis的hash结构存储锁，key为线程标识，value为重入次数，当a获取锁时，判断是否存在该线程标识的锁，不存在则获取锁并设置线程标识和重入次数为1，同时设置过期时间；调用b方法后，b请求锁判断线程标识为true，然后将锁的value加一，重置过期时间；释放锁时，判断标识为true，然后将value减一，此时判断value是否为零，不为零说明不是最外层方法，不用删除锁，重置过期时间后返回，当为0时，则删除锁。
### redisson实现获取锁可重试性，利用信号量机制和redis的pubsub实现，线程如果没有获取到锁会进行等待，等待释放锁的信号，当收到信号后会重新尝试获取锁，如果又没获取到，则继续等待，如果等待时间超时则获取锁失败。（不会过多占用cpu）
### redisson超时续约，利用看门狗机制，当获取到锁后，开启定时任务，每隔一定时间重置锁有效时间，防止业务未执行完锁就被释放掉。

### redisson的multilock可以解决redis主从一致性问题，其原理是将多个redis设置为独立的节点，当线程请求获取锁时，必须获取到每个节点的可重入锁才算获取锁成功，这样，假如某个redis节点宕机了，其他线程无法获取足够数量的可重入锁，那么其他线程也无法获取锁成功，从而避免线程安全问题。

## DAY6
## 1.实现秒杀下单异步下单
## 将秒杀业务分成两步，先用redis完成库存容量、一人一单的判断（使用lua脚本）,再将下单业务放到阻塞队列中利用独立线程实现异步下单，最后使用jmeter进行压测，存在阻塞队列的jvm内存限制问题和jvm无数据持久化导致的数据安全问题

## DAY7
## 1.基于redis的消息队列模型
## --redis的list：使用redis的list结构存储消息，消费者和生产者分别位于两端，生产者push，消费者pop，可以实现数据持久化，但不能保证数据不丢失，因为消息被消费者pop走后，如果消费者宕机，那么该消息就永久丢失了。
## --redis的pubsub：redis的pubsub发布与订阅模型，生产者使用publish channal命令向频道中发布消息，生产者通过subscribe channal订阅单个频道或psubscrib pattern订阅多个频道以接受频道内信息，但无法保证数据持久化，也无法避免数据丢失，而且当消费者缓冲区内消息堆积过多时，会丢失后续消息
## 2.使用redis消费者组实现消息队列从而实现异步下单

## --redis stream数据类型之单消费者模式，生产者通过xadd key * k1 v1方式创建消息队列key并插入k1，v1消息，消费者通过xread [block milliseconds] streams key 0(最初的消息)|$(最新的消息)读取消息队列key中的消息，这种方式消息会永久保存在队列，可随时查看，且可被多个消费者读取，也可阻塞读取，但如果消费者读取最新消息后对消息进行处理的过程中，队列里同时来了多条新消息，当消费者处理完后再次读取最新消息时，只能读取一条，那么其他几条新来的消息就被漏读了。
## --redis stream数据类型之消费者组模式，可以通过xgroup key groupname创建队列的消费者组，消费者可以通过xreadgroup key groupname id（0表示从pendinglist读第一条，>表示从被标识的消息开始读），该模式每次对最后读取的消息做标识，下一次读取会从该标识处读取，从而避免漏读，并且每条消息被消费后必须进行确认，如果因为发生异常没有进行确认，该消息就会被放入pendinglist中，消费者可以通过read id为0的消息读取该消息，此外消费者组内对消息是竞争读取，提高消费速度从而有效避免消息堆积。

## DAY8
## 1.redis数据结构geolocation实现查询附近商铺功能
## 该数据结构基于zset结构实现，内部存储value为名称，score为距离的点的集合，其中score的距离是基于存储时添加的经纬坐标转换为二进制数再转变为hash字符串存储的。


# Redis主从
## 数据同步原理
## 1.全量同步：主节点将全部内存数据生成RDB文件发送给从节点，从节点加载整个RDB文件，在这个过程中后续执行的命令则由主节点记录在repl_baklog文件中发给从节点，从节点执行命令从而保证主从一致性，这种同步发生在从节点第一次连接主节点时或者从节点断开时间太久导致repl_baklog文件被写满并且覆盖了从节点的offset时（从节点请求同步时会发送其主节点号和上次同步位置偏移offset，主节点根据主节点号判断是否是第一次连接，然后根据offset发送后续的命令给从节点）

## 2.增量同步：主节点根据从节点的offset返回repl_baklog中offset之后的命令，这种情况发生在从节点断开连接又恢复后，并且offset还未被覆盖时；

## redis哨兵sentinal
## sentinal是redis主从集群外的一组哨兵节点，主要负责监控整个redis集群的健康，并且在redis master宕机后，从slave中选择一个节点成为新master，防止无法按处理写请求，最后返回新主从地址给客户端
## 其监控作用的实现是通过心跳机制，每秒向集群内实例发送ping如果超过一定时间未收到pong则该sentinal认为该实例主观下线，若超过一半sentinal认为主观下线，则判定该实例为客观下线，从而执行故障恢复，sentinal会从slave中选择offset最大，id最小，slave优先级最小的节点成为主节点，并发送slave of no one命令，同时向所有其他节点发送slave of命令选该节点为master，当原master醒来后就变成了新的slave

# 功能补充
## 1.用户发布探店笔记（blog）
## 2.浏览探店笔记
## 3.给笔记点赞以及显示点赞用户排行榜（时间顺序）
## 4.用户关注与取关
## 5.利用redis set交集获取用户的共同关注列表
## 6.使用feed流推送模式实现将blog推送到所有粉丝收件箱
## 7.使用zset结构实现收件箱从而实现滚动分页查询
## 8.使用geo结构存储店铺地理位置从而实现附近商铺功能
## 9.使用bitmap结构实现用户签到
